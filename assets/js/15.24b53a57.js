(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{466:function(a,n,t){"use strict";t.r(n);var v=t(30),e=Object(v.a)({},(function(){var a=this,n=a.$createElement,t=a._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h3",{attrs:{id:"概要"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#概要"}},[a._v("#")]),a._v(" 概要")]),a._v(" "),t("p",[a._v("有简单向复杂描述\n1、接口由interface修饰，其中只有方法的定义，没有方法体，具体\n实现类通过implments实现接口；"),t("br"),a._v("\n抽象类由abstract修饰，其中可以有方法的定义，也可以有具体的方法\n实现，具体实现类通过extends关键字继承抽象类。")]),a._v(" "),t("p",[a._v("以下摘自地址：")]),a._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("https://blog.csdn.net/xw13106209/article/details/6923556\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br")])]),t("p",[a._v("1、Java接口和Java抽象类最大的一个区别，就在于Java抽象类可以提供\n某些方法的部分实现，而Java接口不可以（就是interface中只能定义方法\n，而不能有方法的实现，而在abstract class中则可以既有方法的具体实\n现，又有没有具体实现的抽象方法），这大概就是Java抽象类唯一的优点\n吧，但这个优点非常有用。"),t("strong",[a._v("如果向一个抽象类里加入一个新的具体方法时\n，那么它所有的子类都一下子都得到了这个新方法")]),a._v("，而Java接口做不到\n这一点，"),t("strong",[a._v("如果向一个Java接口里加入一个 新方法，所有实现这个接口的类\n就无法成功通过编译了，因为你必须让每一个类都再实现这个方法才行")]),a._v("，\n这显然是Java接口的缺点，(有些观点)更倾向于使用抽象类，而不是接口\n，因为这更容易扩展。原因就是上面加粗部分所说的。")]),a._v(" "),t("p",[a._v("2、一个抽象类的实现只能由这个抽象类的子类给出，也就是说，这个实现\n处在抽象类所定义出的继承的等级结构中，而由于Java语言的单继承性，\n所以抽象类作为类型定义工具的效能大打折扣。在这一点上，Java接口的\n优势就出来了，"),t("strong",[a._v("任何一个实现了一个Java接口所规定的方法的类都可以具\n有这个接口的类型，而一个类可以实现任意多个Java接口，从而这个类就\n有了多种类型。（使用抽象类，那么继承这个抽象类的子类类型就比较\n单一，因为子类只能单继承抽象类；而子类能够同时实现多个接口，\n因为类型就比较多")]),a._v("。接口和抽象类都可以定义对象，但是只能用他们的\n具体实现类来进行实例化。）")]),a._v(" "),t("p",[a._v("3、从第2点不难看出，Java接口是定义混合类型的理想工具，混合类表明\n一个类不仅仅具有某个主类型的行为，而且具有其他的次要行为。")]),a._v(" "),t("p",[a._v("4、结合1、2点中抽象类和Java接口的各自优势，具精典的设计模式就出来\n了：声明类型的工作仍然由Java接口承担，但是同时给出一个Java 抽象类\n，且实现了这个接口，而其他同属于这个抽象类型的具体类可以选择实现\n这个Java接口，也可以选择继承这个抽象类，也就是说在层次结构中，\nJava 接口在最上面，然后紧跟着抽象类，这下两个的最大优点都能发挥\n到极至了。这个模式就是“缺省适配模式”。在Java语言API中用了这种模式\n，而且全都遵循一定的命名规范：Abstract ＋接口名。\n（A extends AbstractB implements interfaceC，那么A即可以选择\n实现(@Override)接口interfaceC中的方法，也可以选择不实现；\nA即可以选择实现(@Override)抽象类AbstractB中的方法，\n也可以选择不实现）")]),a._v(" "),t("p",[a._v("Java接口和Java抽象类的存在就是为了用于具体类的实现和继承的，\n如果你准备写一个具体类去继承另一个具体类的话，那你的设计就有\n很大问题了。Java抽象类就是为了继承而存在的，它的抽象方法就是\n为了强制子类必须去实现的。")]),a._v(" "),t("p",[a._v("使用Java接口和抽象Java类进行变量的类型声明、参数是类型声明、\n方法的返还类型说明，以及数据类型的转换等。而不要用具体Java类\n进行变量的类型声明、参数是类型声明、方法的返还类型说明，以及数\n据类型的转换等。")])])}),[],!1,null,null,null);n.default=e.exports}}]);